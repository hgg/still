<!DOCTYPE html><html><head><title>Documentation</title><meta charset="UTF-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><script  src=http://localhost:3000/console-JTYDgyiOCto9iPvDoNqE2w==.js></script>
<link rel="stylesheet" media=all href=http://localhost:3000/css/theme-1LM8eJxZF4M_rT4nxNbmoA==.css />
</head><body><header class="header"><a href="http://localhost:3000/">Still</a><nav class="header-nav"><a href="https://github.com/subvisual/still" rel="noopener noreferrer" target="_blank">Github</a><a href="http://localhost:3000/docs">Docs</a></nav></header><style type="text/css">.header {
  height: 80px;
  font-size: 1.2rem;
  display: flex;
  align-items: center;
  padding: 0 2rem;
  justify-content: space-between;
}

.header-nav > a {
  margin-left: 2rem;
}</style><style type="text/css">.header a {
  text-decoration: none;
}</style><h1 class="fancy-title">Documentation</h1><div class="main"><p>If you&#39;re here just to see some code, you can explore the <a href="https://github.com/subvisual/still/tree/master/priv/site">source code for this website</a>. You can also run it in your machine: clone the repository, install the dependencies <code>mix deps.get</code> and run the development server <code>iex -S mix still.dev</code>.</p>

<p>Still takes files from a source directory, runs them through some preprocessors, and places them in an output directory.</p>

<p>ðŸš§ <em>This documentation is incomplete, but we built <a href="https://github.com/subvisual/still/tree/master/priv/site">this website you&#39;re reading</a> with Still to showcase some of its features. Have a look there if you can&#39;t find what you&#39;re looking for here.</em></p>

<h2>Installation</h2>

<p>To install Still you add it to your dependency list. You should be able to add it to any mix project.</p>

<h3>For new projects</h3>

<p>Run <code>mix archive.install hex still</code> to install the archive on your system.</p>

<p>Afterwards, create a site by running <code>mix still.new my_site</code>. That&#39;s it!</p>

<h3>Adding to an existing project</h3>

<p>Add <code>still</code> as a dependency in <code>mix.exs</code>:</p>

<pre><code class="language-elixir">def deps do
  [
    {:still, &quot;~&gt; 0.0.1&quot;}
  ]
end
</code></pre>

<p>Open up <code>config.exs</code> and set the input and output folders:</p>

<pre><code class="language-elixir">config :still,
  input: Path.join(Path.dirname(__DIR__), &quot;priv/site&quot;),
  output: Path.join(Path.dirname(__DIR__), &quot;_site&quot;)
</code></pre>

<p>Create a file <code>index.slime</code> in the input folder.</p>

<h2>Development</h2>

<p>While you&#39;re working on the website, run <code>iex -S mix still.dev</code> to start Still in development mode and your website will be available in <a href="http://localhost:3000/">http://localhost:3000</a>. Still will be watching the the input folder for changes, refreshing the browser when necessary.</p>

<p>In development mode we will also show you compile time errors in the browser.</p>

<h2>Production</h2>

<p>To compile your site, run <code>mix still.compile</code> and the compiled files will be in the output directory. If you&#39;re wondering about how to integrate this compilation step with your CI, checkout the []source code for the Github Action that deploys this site](https://github.com/subvisual/still/blob/master/.github/workflows/site.yml) you&#39;re reading.</p>

<h2>Preprocessors</h2>

<p>Preprocessors are the cornerstone of Still. A preprocessor chain can take a markdown file, execute its embedded Elixir, extract metadata from its front matter, transform it into HTML and wrap it in a layout.</p>

<p>The default preprocessors are declared in the <a href="https://github.com/subvisual/still/blob/master/lib/still/preprocessor.ex#L16"><em>Preprocessor</em> module</a>. Each file in your input directory with one of the declared extensions will be transformed and placed in the same relative directory in the output folder. For instance, the file <code>about.md</code> will become <code>about.html</code> in the output folder, and a file inside a folder <code>blog/post_1.md</code> will also be in the same folder on the output directory <code>blog/post_1.html</code>.</p>

<p>Notice that many file types, such as markdown and CSS , run through EEx, which means you can use EEx syntax in those files. Here&#39;s an example of a CSS file that uses EEx interpolation:</p>

<pre><code class="language-css">html,
body {
  color: &lt;%= Colors.white() %&gt;;
}
</code></pre>

<p><strong>Files, or folders, that start with an underscore are ignored by the compilation step.</strong> These files can be set to run through the pass-through copy, or used as layouts and partials for other files.</p>

<h3>Custom preprocessors</h3>

<p>If the default preprocessors are not enough, you can extend Still with your own. Take the following example:</p>

<pre><code class="language-elixir">defmodule YourSite.JPEG do
  use Still.Preprocessor

  @impl true
  def extension(_), do: &quot;.jpeg&quot;

  @impl true
  def render(file) do
    file
  end
end
</code></pre>

<p>This preprocessor is a module that calls <code>use Still.Preprocessor</code> and implements the <code>render/2</code> and <code>extension/1</code> functions. The <em>render</em> function is used to transform the content and the metadata of a file, and the <em>extension</em> function is used to set the resulting content type. This <em>extension</em> function is not mandatory.</p>

<p>Preprocessors are always part of a transformation chain, and each file will run through the chain, using the output of the one preprocessor as the input of the next. At the moment, the default transformation chains look like this:</p>

<pre><code class="language-elixir">@default_preprocessors %{
  &quot;.slim&quot; =&gt; [Frontmatter, Slime, OutputPath],
  &quot;.slime&quot; =&gt; [Frontmatter, Slime, OutputPath],
  &quot;.eex&quot; =&gt; [Frontmatter, EEx, OutputPath],
  &quot;.css&quot; =&gt; [EEx, CSSMinify, OutputPath, URLFingerprinting],
  &quot;.js&quot; =&gt; [EEx, JS, OutputPath, URLFingerprinting],
  &quot;.md&quot; =&gt; [Frontmatter, EEx, Markdown, OutputPath]
}
</code></pre>

<p>You can see that some files go through a front matter preprocessor, and CSS goes through EEx, which allows for the interpolation mentioned above.</p>

<p>For the example preprocessor defined above, we can add it to the list in the configuration file:</p>

<pre><code class="language-elixir">config :still,
  preprocessors: %{
    &quot;.jpeg&quot; =&gt; [YourSite.JPEG]
  }
</code></pre>

<p>This preprocessor doesn&#39;t do anything to the contents of a file, so the file on the output folder will look exactly like the file in the input folder.</p>

<h2>Passthrough copy</h2>

<p>Some files you don&#39;t need to transform, only to copy from the input to the output. That&#39;s what pass through copy is for.</p>

<p>In your configuration files, if you specify a string on the <code>pass_through_copy</code> key, any file, or folder, whose relative path starts with that same string will be copied over to the output.</p>

<pre><code class="language-elixir">config :still,
  pass_through_copy: [&quot;img/logo.png&quot;]
</code></pre>

<p>In the example above, the file <code>logo.png</code> inside the <code>img</code> folder will be copied to the <code>img</code> folder in the output. But if you write something like this:</p>

<pre><code class="language-elixir">config :still,
  pass_through_copy: [&quot;img&quot;]
</code></pre>

<p>Any file or folder that starts with the string <code>img</code> will be copied, which may include an <code>img</code> folder or a file named <code>img.png</code>. So you need to be mindful of that.</p>

<p>You can also use regular expressions:</p>

<pre><code class="language-elixir">config still,
  pass_through_copy: [~r/.*\.jpe?g/]
</code></pre>

<p>The example above will will copy any file with a <code>.jpg</code> or <code>.jpeg</code> extension.</p>

<p>Sometimes you want to alter the file name or path but keep the content of the files. The <code>:pass_through_copy</code> option allows if you use tuples. The key will be used to match the input folder, and the value will be used to transform the input path:</p>

<pre><code class="language-elixir">config :still,
  pass_through_copy: [css: &quot;styles&quot;]

  # this is also valid:
  # config :still,
  #   pass_through_copy: [{&quot;css&quot;, &quot;styles&quot;}]
</code></pre>

<p>In the example above, the <code>css</code> folder from the input folder but will be renamed to <code>styles</code> in the output folder.</p>

<h2>Layouts</h2>

<p>Layouts wrap other content. To use a layout, set the <code>layout</code> key in front matter. For instance:</p>

<pre><code class="language-slime">---
layout: _layout.slime
---

h1 About Page
</code></pre>

<p>This will look for <code>_layout.slime</code> in your input folder.</p>

<p>The layout file must print the children variable. For instance:</p>

<pre><code class="language-slime">doctype html
html
  body
    = children
</code></pre>

<p>Notice that <code>_layout.slime</code> starts with an underscore. This is because we don&#39;t
want to compile the layout file to the output.</p>

<p>In fact, any file starting with an underscore isn&#39;t compiled to the output, but can be imported by other files.</p>

<h2>Collections</h2>

<p>Collections allow you to group multiple files. For instance:</p>

<pre><code>---
tags: post
title: A blog post
---
</code></pre>

<p>Every file that specifies the <code>post</code> tag will be listed in the <code>post</code> collection.
You can then iterate over this list by accessing the <code>collections</code> variable:</p>

<pre><code class="language-slime">ul
  = Enum.map Map.get(collections, &quot;post&quot;, []), fn x -&gt;
    li
      = link x[:title], to: x[:permalink]
</code></pre>

<h2>View helpers</h2>

<h3>Including other files</h3>

<p>In any file, you can use the <code>include</code> function to import the contents of a different file. As an example:</p>

<pre><code class="language-slim">html
  head
    = include &quot;_includes/head.slim&quot;
  body
    = children
</code></pre>

<h3>Link to other files</h3>

<p>In any file you can call the <code>link</code> function to create a link to somewhere
else. This function will already take care of specifying the <code>rel</code> and <code>target</code> when necessary. It supports both relative and absolute paths:</p>

<pre><code class="language-slim">= link &quot;Home&quot;, to: &quot;/&quot;
= link &quot;Blog&quot;, to: &quot;https://example.org&quot;
</code></pre>

<h3>Custom view helpers</h3>

<p>To call your own functions from the view files, register a module in the config:</p>

<pre><code class="language-elixir">config :still,
  view_helpers: [Your.Module]
</code></pre>

<h2>License</h2>

<p>Still is released under the <a href="./LICENSE">ISC License</a>.</p>
</div><div class="footer"><p>Still was created and is maintained by</p><img alt="Subvisual" src="http://localhost:3000/subvisual.png"></div></body></html>